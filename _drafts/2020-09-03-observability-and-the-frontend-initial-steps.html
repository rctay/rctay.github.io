---
title: "Observability and the frontend: initial steps"
tags: observability
licence: Copyright © 2020 Ray. <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons Attribution 4.0 International License" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
layout: revealjs-white
---

# Observability and the Frontend:

## Initial Steps

<br>
September 2020<br>
Ray / @rctay

Note:
Observability is popular right now in the world of microservices. For those of us working on user-facing web applications, we might have a JavaScript frontend in, say, React or Angular, that fires off calls to those systems. But, despite being the starting point of backend work, there aren't any integrations on the browser-side, compared to the backend side of things (eg. Spring, ASP.NET Core). In this talk, I'll walk through the pieces you need for Wavefront integration on the browser-side. If anything, just come for the pretty graphs!

Agenda:
- Introduction

- How to do it?
  - backend setup
    - you can see requests to external systems, eg. Google authentication
  - frontend setup
    1. track it via a context
    2. report it
    3. propagate it

- What does it look like?

- hopefully this opens

Further work:
- What should I instrument?
- Why do I need observability?
- What makes a good trace?
- wavefront over zipkin / prometheus?
  - in the first place, what are the latter?

---

# Introduction


## What is observability?


## Monitoring = Observability?


## Monitoring
- identify symptoms of a problem ("error rate is up")
- USE: utilization (free memory), saturation (CPU run queue length), errors
- RED: request rate, error rate, duration of request


## Observability

![Observability definition by Charity Majors]({{ "/public/img/2020-09-03-observability-and-the-frontend-initial-steps/Observability-definition-Charity-Majors.png" | relative_url}}) <!-- .element: style="max-width: 60%" -->

Note:
Source: https://twitter.com/mipsytipsy/status/1231833240433917952

---

# Background

Breaking down what we have, and what we need


<!-- .slide: data-background-image="{{ "/public/img/2020-09-03-observability-and-the-frontend-initial-steps/Youtube-spa-example.png" | relative_url}}" data-background-size="80%" -->

Note:
Let's take a closer look at a SPA, and see what kind of work is involved.

For the main content - you could have one API call for that, eg.

For the related videos - you might have some API call for that, to load 20 related videos.
And to give a seamless browsing experience, without a "blank" browser background which you see when you request a totally new page with HTML, JS, CSS, your frontend can "trap" browser navigations, so although your URL shows a different URL, the browser didn't have to request a new page with new HTML, JS, CSS.

## old
I'll assume most people are familiar with routing in Single-page applications. One blob of html gets sent to the browser when the user first visits the page, subsequently you might go to different "pages", but the browser isn't retrieving from scratch a separate HTML, CSS, JS, it is still the same initial blob when you first visited the page. You might see different urls in the url bar, but its the code (or frontend application) in the browser that is handling these, changing what gets displayed.

The idea is we just send a single blob of HTML, CSS, JS once to the browser, so we can give the user a seamless or even native feel, because any pages or data that's need are retrieved in the background, the user doesn't see a "whiteout" in the browser which you get when loading a separate page of HTML, CSS, JS. On the developer side, it opens new possibilities, like how we can preserve data or state between different pages, which is not easily done or even possible when different pages get loaded.

Let's identify the unit of work to be a trace/span.


### Navigations

- `/overview`: one unit of work
  - `GET /api/teams/31`: subunit of work
  - `GET /api/members/47`: subunit of work
- `/about`: another unit of work

Note:
...

- Routing (in your favourite framework)
  - `@angular/router`
  - `react-router-dom`

So now we have a rough seed or a starting point - on how we can dilenate work in our system, our picture of the system will be broken up according to a page that the user visits. any


### Tracing

![Example of trace and spans from Wavefront]({{ "/public/img/2020-09-03-observability-and-the-frontend-initial-steps/wavefront-tracing_trace_spans.png" | relative_url}})

Note:
Now we have an idea of what the system looks like. Let's now take a look at the other side of things - what traces and spans are.
If you take a look at the diagram, we have a number of spans, and they are all tied together, by a trace. We can also relate spans to one another. The way the tracing platform relates spans is through a parent-child relationship. So you can report the root span to the tracing platform, then let's say for a child span, GET-style/id/make, report the child span with a parent span ID of the root span. So if you login to the tracing platform UI, it will nicely tie them together, and show this nesting hierarchy.


### Definitions

- span: an individual unit of work
  - eg. Printing.printShirts, Packaging.giftWrap
- trace: an individual workflow, made up of one or more spans
  - eg. shopping request


### Hatching a Plan

- for every navigation, start a trace
  -
  - for any API calls, associate them to this trace
    - for any outgoing HTTP calls to external services, associate them to this trace

### Alternatives

-

---

# Walkthrough


## What you'll need

- A Wavefront instance
- An API key

---

# Backend

![Table of Wavefront SDKs]({{ "/public/img/2020-09-03-observability-and-the-frontend-initial-steps/Wavefront-sdks-table.png" | relative_url}}) <!-- .element: style="max-width: 60%" -->


- Pick the appropriate SDK for your backend stack
- Wire it up to the Wavefront instance and API key

Note:
I'll first start with the easy part, which is wiring up the backend.


Out-of-the-box:
- report an incoming API request as a span
- report an outgoing HTTP calls as a span<br>
- (bonus) metrics eg. request rate, errors


- correlate those spans to a parent span
- propagation in OpenTracing terminology
- we'll need to set these headers when making an API request

```
wf-ot-traceid
```

Note:
The SDKs are also able to pick up http headers, so that it can associate API requests to the backend with a parent span.

---

# Frontend

- for every navigation, create a trace/span
- report this trace to Wavefront
- associate backend calls with this trace


## Navigation

- subscribe to routing events
- NavigationStart: generate new trace ID, start span representing unit of work of
- NavigationEnd: end
-

```typescript
import { Router, NavigationStart, NavigationEnd } from '@angular/router';
import { WavefrontTracerService } from './wavefront-tracer.service';

export class RoutingSubscriber {
  constructor(private router: Router, private tracer: WavefrontTracerService) { }

  subscribeToRouteEvents() {
    this.router.events.subscribe(this.routerHandler.bind(this));
  }

  routerHandler(event: Event) {
    if (event instanceof NavigationStart) {
      this.tracer.startSpan();
    } else if (event instanceof NavigationEnd) {
      this.tracer.endSpan(
        event.url, // operation name
        this.route.snapshot.params // team = 'a-team'
      );
    }
  }
}
```

<!-- .element: style="font-size: 0.4em" -->


### Reporting

```typescript
import { WavefrontDirectClient } from 'wavefront-sdk-javascript';
import { v4 as uuidv4 } from 'uuid';

export class WavefrontTracerService {
  startSpan() {
    this.activeTraceId = uuidv4();
    this.activeSpanId = uuidv4();
    this.startTime = new Date().getTime();
  }

  endSpan(operationName: string, additionalTags = {}) {
    this.client.sendSpan(
      operationName,
      this.startTime,
      new Date().getTime() - this.startTime,
      'teamup.cfapps.io', // source
      this.activeTraceId,
      this.activeSpanId,
      null, // parent span IDs
      null, // follows from
      [
        ['application', 'teamup'],
        ['service', 'frontend'],
        ...Object.entries(additionalTags)
      ],
      null // span logs
    );
  }

  private activeTraceId: string;
  private activeSpanId: string;
  private startTime: number;

  constructor(private client: WavefrontDirectClient) { }
}
```

<!-- .element: style="font-size: 0.3em" -->


### Associating

```typescript
import { WavefrontTracerService } from './wavefront-tracer.service';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

/** Based on: TextMapPropagator in https://github.com/wavefrontHQ/wavefront-opentracing-sdk-java/ */
const BAGGAGE_PREFIX = 'wf-ot-';
const TRACE_ID = `${BAGGAGE_PREFIX}traceid`;
const SPAN_ID = `${BAGGAGE_PREFIX}spanid`;

export class WavefrontHttpInjectorService implements HttpInterceptor {
  constructor(private tracer: WavefrontTracerService) { }

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const updatedReq = req.clone({
      setHeaders: {
        [TRACE_ID]: this.tracer.getActiveTraceId(),
        [SPAN_ID]: this.tracer.getActiveSpanId()
      }
    });

    return next.handle(updatedReq);
  }
}
```

<!-- .element: style="font-size: 0.35em" -->

---

# Conclusion

Note:
Hopefully you are now able to have a more complete picture of work in your system.

---

## References

1. Observability - A 3-Year Retrospective https://thenewstack.io/observability-a-3-year-retrospective/

   - The ‘00s Spawned a New Vendor Breed: APM
   - Cardinality and Its Relation to Complex Distributed Systems
     - Without Access to High Cardinality Data, Good Luck Debugging
   - What Observability Looks Like in Practice
   - Observability and Its Progenitors
   - How Observability’s Purpose and Value Have Been Misrepresented
   - The Future of Observability
   - Engage in Constant Conversation with Your Code
   - For Engineers … but also Engineering-adjacent Teams

2. https://medium.com/@copyconstruct/monitoring-and-observability-8417d1952e1c

   - Baby’s first Observability
   - Monitoring is for symptom based Alerting
   - And then there’s “Observability”
   - Debugging
   - Context Matters
   - One last thing

